---
title: Evenly Spacing Probes and Visualising Probe Spacing
output:
  html_notebook:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

At this stage, the uniquely-mapped probes have been filtered for structure. They now have to be spaced evenly. This code attempts to do that, as well as evaluate the consistency of the spacing.

```{r }
library(tidyverse)
library(Gviz)
library(rafalib)
```

# Reading in the file

```{r message=FALSE}
bed_align <- read_tsv(file = "Tgfbr1_cleaned_probes_chr_sC.bed", col_names = FALSE)

colnames(bed_align) <- c("chromosome", "start", "end", "probe", "Tm")

bed_align
```

# Creating evenly-spaced probe sets

This code attempts to create multiple sets of probes which are spaced at a distance of more than or equal to `min_probe_spacing`. 

Each probe set begins at a certain probe in the full probe collection. Let us refer to it as probe A.

The code finds the next probe (let us refer to this as probe B) which is at least at a distance of `min_probe_spacing` from the probe A. Then the next probe is searched which is at least at a distance of `min_probe_spacing` from probe B. This process is continued until the last viable probe fulfilling the criterion is reached. All the resulting probes are then considered part of this particular probe set.

Picking a different starting probe A should result in a different probe set being formed. This results in multiple probe sets being formed, each with their own starting probe A.

At the end, one probe set is to be picked, which can be used for region-specific extraction.


**Note**:

This code does not act directly on the probes per se. Rather, it acts on the row indices of the object `bed_align`, each of which correspond to a certain probe. Hence, each generated probe set is not actually a set of probes; rather, it is a set of *row indices*, corresponding to the probes in `bed_align`. 

If a satisfactory probe set is found from among the probe sets generated by the code, that particular probe set can be extracted from `bed_align` by subsetting it using the row indices. 


```{r }
x <- vector(mode = "list", length = (nrow(bed_align) - 1)) # initiating a blank list for holding all the probe sets

names(x) <- paste0(as.character(1:(nrow(bed_align) - 1)))

names(x) %>% head()
```


```{r }
min_probe_spacing <- 3000 # minimum space to be kept between end of first probe and start of next

for(i in 1:(nrow(bed_align) - 1)){
  
  j <- i
  
  a <- j+1
  
  while(a <= nrow(bed_align)){
    
    if((bed_align$start[a] - bed_align$end[j]) <= min_probe_spacing){
      a <- a+1
    } else {
      x[[as.character(i)]] <- append(x[[as.character(i)]], c("probe_1" = j, "probe_2" = a))
      j <- a
      a <- j+1
    }
    
  } 
}
```

```{r }
length(x)
```

As seen below, each element in the list is a vector of row indices referring to specific probes contained in the `bed_align` data frame. Many of these indices are repeated twice; hence, they have to be deduplicated to create a list of unique indices. This will be done subsequently.

```{r }
x$`1`
```

Firstly, the fact that the probe set list  contains null elements has to be addressed. An example is shown below.  

```{r }
x$`821`
```

These null elements are removed in the following way.

```{r }
x <- purrr::compact(x)  # removing null list elements
```

Getting a unique set of probe indices.

```{r }
x <- sapply(x, unique)
x$`1`
```

Giving better names for the elements in the probe set list.

```{r }
names(x) <- paste0("probeset_", names(x))

names(x) %>% head()
```

Getting the number of probes present in each probe set.

```{r }
probeset_lengths <- sapply(x, length)

names(probeset_lengths) <- NULL

probeset_lengths %>% head()

probeset_lengths %>% table()
```

The probe sets with the most number of probes contain 20 probes each. Getting a modified collection of probe sets consisting of these probe sets.

```{r }
largest_probesets <- x[which(probeset_lengths == max(probeset_lengths))]
```

Taking a look at at the indices in the first probe set.

```{r }
largest_probesets[[1]]
```

# Getting probe spacing statistics

```{r }
probe_spacing <- vector(mode = "list", length = length(largest_probesets)) # creating null list for holding probe spacing values for all probe sets

names(probe_spacing) <- names(largest_probesets)

mean_probe_spacing <- vector(mode = "numeric", length = length(largest_probesets)) # creating null vector for holding probe spacing values for all probe sets

names(mean_probe_spacing) <- names(largest_probesets)

interquartile <- vector(mode = "numeric", length = length(largest_probesets))  # creating null vector for holding interquartile ranges of all probe sets

names(interquartile) <- names(largest_probesets)

for(i in seq_along(largest_probesets)){  # iterating along all the probe sets
  
  current_set_spacing <- vector(mode = "numeric", length = length(largest_probesets[[i]])) # create a null vector for holding distance between end of one probe and start of next probe (i.e., probe spacing) for current probe set
  
  for(j in 1:(length(current_set_spacing) - 1)){ # iterating along the probes in single probe set
    
    selected_probe_idx <- largest_probesets[[i]][j]  # index of selected probe in probe set
    
    next_probe_idx <- largest_probesets[[i]][j+1] # index of the next probe in probe set
    
    current_set_spacing[j] <- (bed_align$start[next_probe_idx] - bed_align$end[selected_probe_idx]) # start of next probe - end of selected probe
  }
  
  current_set_spacing <- current_set_spacing[-length(current_set_spacing)] # remove final element of current_set_spacing, which is a zero and is redundant
  
  probe_spacing[[i]] <- current_set_spacing # probe spacing for entire probe set
  
  mean_probe_spacing[i] <- mean(current_set_spacing)
  
  interquartile[i] <- IQR(current_set_spacing) # interquartile range of probe spacing of probe set
}
```

Taking a look at the probe spacing in the first probe set.

```{r }
probe_spacing$probeset_1
```

Hence, most of the probes are spaced at around 3 kb from each other in the first set.

Taking a look at the mean probe spacing for each probe set.

```{r }
mean_probe_spacing %>% enframe()
```

The mean probe spacing for each of these probe sets is close to 3 kb.

Taking a look at the interquartile range of the probe spacing for each probe set.

```{r }
interquartile %>% enframe()
```

For the most part, the probe spacing in all the probe sets is quite consistent, without too much deviation from the spacing distance of 3 kb. Most of the probe distances are at most greater than 3 kb by 100 or so bp.


```{r }
mypar(1, 1)

boxplot(mean_probe_spacing, main="Mean probe spacing for each set", horizontal=TRUE)
```


```{r }
boxplot(interquartile, main = "Interquartile ranges of probe spacing for each set", horizontal=TRUE)
```

```{r }
hist(interquartile, main = "Interquartile ranges of probe spacing for each set")
```

The first probeset seems satisfactory enough in terms of probe spacing criteria. Hence, we finalise it as the set of probes to use. Taking a look at the actual probes in this probe set.


```{r}
bed_align[largest_probesets$probeset_1, ]
```


```{r }
spaced_probes <- bed_align[largest_probesets$probeset_1, ]
```

# Writing the selected spaced probe set to a file

```{r }
write_tsv(x = spaced_probes, path = "Tgfbr1_spaced_probes.bed", col_names = FALSE)
```

# Visualizing the spacing of the probe sets using Gviz

```{r }
spaced_probe_ranges <- GRanges(seqnames = spaced_probes$chromosome, ranges = IRanges(start = spaced_probes$start, end = spaced_probes$end), probe = spaced_probes$probe, Tm = spaced_probes$Tm)

probe_track <- Gviz::AnnotationTrack(range = spaced_probe_ranges, chromosome = 4, name  = "probes")

gtrack <- GenomeAxisTrack()

tgfbr1_bounds <- c("start" = 47353222, "end" = 47414926)

tgfbr1_range <- GRanges(seqnames = c("chr4"), ranges = IRanges (start = tgfbr1_bounds["start"], end = tgfbr1_bounds["end"]))

tgfbr1_track <- AnnotationTrack(range = tgfbr1_range, name = "Tgfbr1")
```

Here is a visual look at the probe spacing for the first probe set along mouse Tgfbr1. 

```{r }
plotTracks(trackList =  list(probe_track, gtrack, tgfbr1_track))
```

This spacing was also viewed online using the UCSC genome browser. The barcode-like lines above Tgfbr1 are the probes.

```{r}
knitr::include_graphics("./ucsc_probe_alignment.png")
```


```{r }
spaced_probes$Tm %>% summary()
```


